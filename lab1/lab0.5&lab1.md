# lab0.5&lab1


**对实验报告的要求：**

- 基于 markdown 格式来完成，以文本方式为主
- 填写各个基本练习中要求完成的报告内容
- 列出你认为本实验中重要的知识点，以及与对应的 OS 原理中的知识点，并简要说明你对二者的含义，关系，差异等方面的理解（也可能出现实验中的知识点没有对应的原理知识点）
- 列出你认为 OS 原理中很重要，但在实验中没有对应上的知识点

## lab0.5 练习1：使用GDB验证启动流程
为了熟悉使用qemu和gdb进行调试工作,使用gdb调试QEMU模拟的RISC-V计算机加电开始运行到执行应用程序的第一条指令（即跳转到0x80200000）这个阶段的执行过程，说明RISC-V硬件加电后的几条指令在哪里？完成了哪些功能？要求在报告中简要写出练习过程和回答。

### 练习过程
1.通过```make debug```启动qemu，计算机加电
2.通过```make gdb``` 连接gdb,开始调试
3.使用```break *0x80200000```在 0x80200000 处设置断点
4.不断使用```si```，观察即将执行的指令的地址
5.在执行过程中发现当执行完0x00001010处的指令之后下一个将要执行的地址跳转到了0x8000000,之后就是正常执行到了0x80200000
6.随后我重新加电后使用```x/10i $pc```得到即将执行的10条汇编指令,我同时还尝试了在此处使用```x/10i x1000```发现得到的汇编指令是相同的，因此说明```x/10i $pc```指令仅仅是取出了此时pc所在位置的后10个指令，而并没有对指令的内容进行判断，否则将会跳转。
7.我单独取出了加电后执行到0x1010前的代码进行逐行分析：
```0x1000: auipc t0,0x0```：将程序计数器（PC）的高20位与一个立即数（这里是0x0）左移12位后的值相加（就相当于左移12位），然后将结果写入寄存器t0。由于立即数是0，所以t0将包含当前指令地址加4的值。
```0x1004: addi a1,t0,32```：将寄存器t0的值与立即数32相加，结果写入寄存器a1。此时，a1将包含auipc指令地址加36（即当前指令地址加32）的值。
```0x1008: csrr a0,mhartid```：从控制状态寄存器（CSR）中读取值。mhartid是硬件线程ID寄存器，该指令读取当前硬件线程的ID并将其存储在寄存器a0中。
```0x100c: ld t0,24(t0)```：从内存中加载一个64位值。它从auipc指令计算出的地址（即t0的值）加上24字节偏移量的位置加载一个双字到t0寄存器。
```0x1010: jr t0```：将程序计数器设置为寄存器t0的值，从而跳转到t0寄存器所指向的地址继续执行。由于t0之前加载了从内存特定位置读取的值，这实际上是一个间接跳转。

因此这几行指令完成了
1.初始化寄存器以设置程序环境。
2.读取当前硬件线程的ID。
3.加载一个函数或程序入口点的地址。
4.跳转到该地址以继续执行程序。




## lab1 练习1：理解内核启动中的程序入口操作
阅读 kern/init/entry.S内容代码，结合操作系统内核启动流程，说明指令 la sp, bootstacktop 完成了什么操作，目的是什么？ tail kern_init 完成了什么操作，目的是什么？



## lab1 练习2：完善中断处理 （需要编程）
请编程完善trap.c中的中断处理函数trap，在对时钟中断进行处理的部分填写kern/trap/trap.c函数中处理时钟中断的部分，使操作系统每遇到100次时钟中断后，调用print_ticks子程序，向屏幕上打印一行文字”100 ticks”，在打印完10行后调用sbi.h中的shut_down()函数关机。

要求完成问题1提出的相关函数实现，提交改进后的源代码包（可以编译执行），并在实验报告中简要说明实现过程和定时器中断中断处理的流程。实现要求的部分代码后，运行整个系统，大约每1秒会输出一次”100 ticks”，输出10行。



在操作系统启动过程中，内核初始化函数kern_init()的执行流程如下：
1. 从kern/init/entry.S文件开始执行，首先会输出一些信息，表明操作系统正在初始化。
2. 接着，设置中断向量表(stvec)，使其指向kern/trap/trapentry.S中的一个特定标记，以便在发生中断时能够跳转到相应的处理代码。
3. 在kern/driver/clock.c文件中，设置第一个时钟事件，并启用时钟中断。
4. 启用全局的S模式中断使能位，从而允许S模式下的中断。
5. 之后，系统开始不断触发时钟中断。
   
当发生一次时钟中断时，执行流程如下：
1. 通过调用set_sbi_timer()函数，利用OpenSBI的时钟事件来触发一个中断，程序会跳转到kern/trap/trapentry.S中的__alltraps标记。
2. 在__alltraps标记处，保存当前执行流的上下文，并通过函数调用，切换到kern/trap/trap.c中的中断处理函数trap()的上下文。
3. 将保存的上下文作为一个结构体传递给trap()函数作为参数。
4. 在trap()函数中，根据中断类型进行分发处理（通过trap_dispatch()或interrupt_handler()函数）。
5. 执行与时钟中断对应的处理语句，包括累加计数器和设置下一次时钟中断。
6. 完成中断处理后，返回到kern/trap/trapentry.S。
7. 恢复之前保存的上下文，结束中断处理。







## lab1 扩展练习 Challenge1：描述与理解中断流程
回答：描述ucore中处理中断异常的流程（从异常的产生开始），其中mov a0，sp的目的是什么？SAVE_ALL中寄寄存器保存在栈中的位置是什么确定的？对于任何中断，__alltraps 中都需要保存所有寄存器吗？请说明理由。

## lab1 扩增练习 Challenge2：理解上下文切换机制
回答：在trapentry.S中汇编代码 csrw sscratch, sp；csrrw s0, sscratch, x0实现了什么操作，目的是什么？save all里面保存了stval scause这些csr，而在restore all里面却不还原它们？那这样store的意义何在呢？

## lab1 扩展练习 Challenge3：完善异常中断
编程完善在触发一条非法指令异常 mret和，在 kern/trap/trap.c的异常处理函数中捕获，并对其进行处理，简单输出异常类型和异常指令触发地址，即“Illegal instruction caught at 0x(地址)”，“ebreak caught at 0x（地址）”与“Exception type:Illegal instruction"，“Exception type: breakpoint”。（
